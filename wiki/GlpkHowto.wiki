#summary Quick overview of the interface, plus hello world example.

= Introduction =

This project provides an Erlang interface to GLPK.

You probably know what [http://www.gnu.org/software/glpk/ GLPK] is, otherwise, you wouldn't have much interest in the project.  

= Port vs. Linked-In =

In Erlang you have the choice between a port (forked program communicating over a socketpair) or a linked-in driver (dynamically loaded library residing in Erlang VM's address space).

Generally linked-in drivers are dangerous because they can destabilize the VM, but are sometimes used because they offer lower latency.  Since solving a linear program is a very heavyweight operation, the latency of talking over a pipe is probably moot.  Furthermore, it's very easy to shut down a subprocess without blocking the Erlang VM, whereas a linked-in driver with a thread that is doing a long running computation can potentially block the Erlang VM if the port_close method is invoked during the long running computation (which could happen if the port owner dies after initiating a large linear program solve).

For these reasons the default mode of operation is port.  You can select linked-in driver when constructing a handle, but it's probably a bad idea.  (Really, the only reason it is there is because I have a way to convert a linked-in driver to a port, so I always write the linked-in driver first).

= Calling Conventions =

Much of the software is this package is auto-generated, and therefore the interface is a near-literal translation of the C api, with the following conventions:


== Return Types ==

Any method can return { error, Reason }, which indicates an error not associated with a GLPK return value.  except for the port dying, this generally means an internal_error in the driver (i.e., software defect by me!).

In addition each method can return a value which depends upon the return value of the associated glpk method.  This value is *never* an Erlang tuple so you can distinguish it from the error case.

|| C return type || Erlang type ||
|| void || 'ok' ||
|| int || integer () ||
|| enumeration || 'lowercase_first_enum_val' | 'lowercase_second_enum_val' ... ||
|| double || float () ||

With respect to enumerations, basically an enum on the C side is associated with a sum of atoms type on the Erlang side, with lowercasing for convenience.  So something like the return type for {{{glp_get_prim_stat}}}, which is (essentially) declared as
{{{
enum
{
GLP_UNDEF, 
GLP_FEAS,
GLP_INFEAS,
GLP_NOFEAS 
}
}}}
would be the Erlang type 
{{{
'glp_undef' | 'glp_feas' | 'glp_infeas' | 'glp_nofeas'
}}}
Also some methods, e.g. {{{glp_simplex}}}, return 0 to indicate success but otherwise an enumeration.  I define this as 'glp_success'.

The interface file ({{{glpkerl.erl}}} generates proper EDoc and dialyzer type signatures so hopefully it is clear what is going on.

== Argument Types ==

For each mapped GLPK function, the argument types are mapped to Erlang as follows:

|| C argument type || Erlang type ||
|| glp_prob* || implicit: contained in the glpkerl instance ||
|| int || integer () ||
|| double || number () ||
|| const int* || list (integer ()) ||
|| const double* || list (number ()) ||
|| enumeration || 'lowercase_first_enum_val' | 'lowercase_second_enum_val' ... ||
|| const struct X* || proplist () ||

With respect to enumerations, basically an enum on the C side is associated with a sum of atoms type on the Erlang side, with lowercasing for convenience.  So for instance the msg_level parameter would be ( 'glp_msg_off' | 'glp_msg_err' | 'glp_msg_on' | 'glp_msg_all' ).

With respect to (pointers to) structures, I map these to proplists where the keys are atoms corresponding to the member names of the structure.  So a call to {{{glp_simplex}}} might look like
{{{
  { ok, Lp } = glpkerl:new (),
  ...
  glp_success = glpkerl:simplex (Lp, [ { msg_level, 'glp_msg_off' } ]),
}}}